{"sample_order": 93, "function": "def equation(t: np.ndarray, x: np.ndarray, v: np.ndarray, params: np.ndarray) -> np.ndarray:\n    \"\"\" Mathematical function for acceleration in a damped nonlinear oscillator\n\n    Args:\n        t: A numpy array representing time.\n        x: A numpy array representing observations of current position.\n        v: A numpy array representing observations of velocity.\n        params: Array of numeric constants or parameters to be optimized\n\n    Return:\n        A numpy array representing acceleration as the result of applying the mathematical function to the inputs.\n    \"\"\"\n    \"\"\"\n    Selects the mathematical function that most accurately represents acceleration in a damped nonlinear oscillator system.\n    \n    Args:\n        t: An array of time data points.\n        x: An array of position data points.\n        v: An array of velocity data points.\n    \n    Returns:\n        A function that best represents acceleration in a damped nonlinear oscillator system.\n    \"\"\"\n    best_equation = None\n    best_r_value = None\n    \n    for equation in [equation_v1, equation_v2]:\n        try:\n            _, _, _, _, _ = curve_fit(equation, t, v, p0=PRAMS_INIT)\n            r = calculate_r_value(v, equation(t, x, v, PRAMS_INIT))\n        except Exception:\n            continue\n    \n        if best_r_value is None or r < best_r_value:\n            best_r_value = r\n            best_equation = equation\n    \n    return best_equation\n\n", "score": null}