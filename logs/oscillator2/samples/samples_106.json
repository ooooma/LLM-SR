{"sample_order": 106, "function": "def equation(t: np.ndarray, x: np.ndarray, v: np.ndarray, params: np.ndarray) -> np.ndarray:\n    \"\"\" Mathematical function for acceleration in a damped nonlinear oscillator\n\n    Args:\n        t: A numpy array representing time.\n        x: A numpy array representing observations of current position.\n        v: A numpy array representing observations of velocity.\n        params: Array of numeric constants or parameters to be optimized\n\n    Return:\n        A numpy array representing acceleration as the result of applying the mathematical function to the inputs.\n    \"\"\"\n    \"\"\" Derivative of acceleration common function for an underdamped oscillator.\n    \n    Args:\n        t: A numpy array representing time.\n        y: A numpy array representing current position and velocity.\n        params: Array of numeric constants or parameters to be optimized\n    \"\"\"\n    x, v, w = y\n    dxdt = v\n    dvdt = params[0]*np.exp(-0.2*t)*np.sin(10*t) - params[1]*v - params[2]*x\n    dwdt = params[3]\n    \n    return np.array([dxdt, dvdt, dwdt])\n    \n    \"\"\" This is a code for finding sparse equation using some function optimization methods\"\"\"\n    import numpy as np\n    from scipy import optimize\n    \n    # Example constant values\n    gamma_1 = [2]\n    omega_0 = [1]\n    force = lambda t: np.exp(-0.2 * t) * np.sin(10 * t)\n    params_init = np.array([1.0]*MAX_NPARAMS)\n\n", "score": null}