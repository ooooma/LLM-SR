{"sample_order": 98, "function": "def equation(t: np.ndarray, x: np.ndarray, v: np.ndarray, params: np.ndarray) -> np.ndarray:\n    \"\"\" Mathematical function for acceleration in a damped nonlinear oscillator\n\n    Args:\n        t: A numpy array representing time.\n        x: A numpy array representing observations of current position.\n        v: A numpy array representing observations of velocity.\n        params: Array of numeric constants or parameters to be optimized\n\n    Return:\n        A numpy array representing acceleration as the result of applying the mathematical function to the inputs.\n    \"\"\"\n    \"\"\"\n    Applies the SimOEN activation function to each channel of the feature maps.\n    \n    Args:\n        feature_maps (torch.Tensor): Input tensor of feature maps with shape (batch, channels, height, width).\n    \n    Returns:\n        torch.Tensor: Output tensor with SimOEN activation applied along the channel dimension.\n    \"\"\"\n    # Apply the SimOEN function along channels for all other dimensions\n    scaled_elu_maps = torch.zeros_like(feature_maps)\n    for i in range(feature_maps.size(1)):\n        channel = feature_maps[:, i, :, :]\n        simoens = torch.where(channel > 1, channel / torch.sqrt(2),\n                              torch.where(channel < -1 / torch.sqrt(2),\n                                          1 / torch.sqrt(2),\n                                          F.tanh(channel)))\n        scaled_elu_maps[:, i, :, :] = simoens\n    return scaled_elu_maps\n\n", "score": null}