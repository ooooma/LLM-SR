{"sample_order": 80, "function": "def equation(t: np.ndarray, x: np.ndarray, v: np.ndarray, params: np.ndarray) -> np.ndarray:\n    \"\"\" Mathematical function for acceleration in a damped nonlinear oscillator\n\n    Args:\n        t: A numpy array representing time.\n        x: A numpy array representing observations of current position.\n        v: A numpy array representing observations of velocity.\n        params: Array of numeric constants or parameters to be optimized\n\n    Return:\n        A numpy array representing acceleration as the result of applying the mathematical function to the inputs.\n    \"\"\"\n    \n    \"\"\"\n    Describe mathematical relationship between acceleration and time, position, velocity, normal forces, and sharp forces.\n    \n    Assume nonlinear interaction between forces and movement, constant damping coefficient.\n    \n    Parameters:\n    ----------\n        t, x: numpy array -\n            Position arrays (time, position)\n        v: numpy array -\n            Velocity observations.\n        params: numpy array -\n            Array of parameters including nonlinear interaction signatures for each force type.\n    \n    Returns:\n    --------\n        acceleration: np.array\n            Calculated acceleration.\n    \n    \"\"\"\n    constant = params[7]\n    sharp = params[8]\n    damp = params[9]\n    lt = params[10]\n    sig_fft, sig_max = FCN_2nd(t=t, lf=lt)\n    \n    acc0 = constant * v\n    acc1 = sharp * np.cos(sig_fft * t + phase)\n    acc2 = damp * lt * sig_max * sig_fft * v\n    acc3_ = lt(v[0]) + lt(v[1])\n    \n    # Consider global averaging of velocity\n    average_v = np.mean(v) \n    \n    acc3 = lambda v: average_v + acc3_ * v\n    \n    acc = acc0 + acc1 + acc2 + acc3\n\n", "score": null}